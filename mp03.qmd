---
title: "Spotify Songs Analysis"
author: "Gisell Bennett"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: false
    embed-resources: false
    theme: cosmo  
    code-overflow: wrap
    css: styles.css  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# üìò Introduction
This mini-project explores a large Spotify playlist dataset and corresponding song characteristics. The goal is to analyze how user-created playlists reflect patterns in music preference and how these patterns align with musical attributes like energy, danceability, and valence.

## üéµ Song Characteristics Dataset

```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

load_songs <- function() {
  library(readr)
  library(dplyr)
  library(tidyr)
  library(stringr)

  # Define directory, file path, and URL
  dir_path <- "data/mp03"
  file_path <- file.path(dir_path, "songs.csv")
  url <- "https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv"

  # Create directory if it doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }

  # Download the file if it doesn't exist
  if (!file.exists(file_path)) {
    download.file(url, file_path, method = "libcurl")
  }

  # Read the CSV
  SONGS <- read_csv(file_path, show_col_types = FALSE)

  # Clean and split artist list
  SONGS_clean <- SONGS |>
    mutate(
      artists = str_remove_all(artists, "\\[|\\]|'")
    ) |>
    separate_rows(artists, sep = ",\\s*") |>
    rename(artist = artists)

  return(SONGS_clean)
}

songs_df <- load_songs()

library(knitr)

songs_df |>
  select(name, artist, danceability, energy, valence, duration_ms) |>
  head(10) |>
  kable(caption = "Song Characteristics")
```

## üìù Spotify Million Playlist Dataset

In Task 2, I encountered a challenge with the Spotify Million Playlist Dataset. The original GitHub repository had become unreliable, as many files returned 404 errors. This issue was also flagged in Piazza by the professor and other students. To work around this, I focused on downloading a single available chunk: mpd.slice.0-999.json. Using the httr package, I checked the file‚Äôs availability and downloaded it if accessible. If the file could not be retrieved, the script produced a notification. This allowed me to move forward with a sample-based analysis despite the broader dataset being partially inaccessible.

```{r}
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: Show Code
#| include: false

library(httr)
library(jsonlite)

# Define the base URL and file name
base_url <- "https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/refs/heads/main/data1/"
file_name <- "mpd.slice.0-999.json"
file_url <- paste0(base_url, file_name)

# Set local file path
local_file_path <- file.path("spotify_data", file_name)

# Check and download the file
response <- GET(file_url)

if (status_code(response) == 200) {
  if (!dir.exists("spotify_data")) {
    dir.create("spotify_data")
  }
  writeBin(content(response, "raw"), local_file_path)
  message("Downloaded: ", file_name)
} else {
  message("Error downloading: ", file_name, 
          " - Status code: ", status_code(response))
}

# Load and inspect the JSON file
if (file.exists(local_file_path)) {
  json_data <- fromJSON(local_file_path)
  json_data_df <- as.data.frame(json_data)
  small_json_data <- head(json_data_df, 10)
  print("First 10 records:")
  print(small_json_data)
} else {
  print("No data found to load.")
}

```

## Questions
### Identifying Characteristics of Popular Songs

1. How many distinct tracks and artists are represented in the playlist data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Number of distinct tracks
distinct_tracks <- songs_df |>
  distinct(name) |>
  count()

# Number of distinct artists
distinct_artists <- songs_df |>
  distinct(artist) |>
  count()

print(paste("Distinct tracks:", distinct_tracks$n))
print(paste("Distinct artists:", distinct_artists$n))
```
2. What are the 5 most popular tracks in the playlist data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Top 5 most popular tracks
top_5_popular_tracks <- songs_df |>
  arrange(desc(popularity)) |>
  slice_head(n = 5) |>
  select(name, popularity)

print(top_5_popular_tracks)
```

3. What is the most popular track in the playlist data that does not have a corresponding entry in the song characteristics data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Summarize and calculate the number of appearances for each track
track_appearances <- songs_df |>
  group_by(name) |>
  summarise(num_appearances = n(), .groups = 'drop') |>
  arrange(desc(num_appearances))

# Check if there are any tracks with 0 appearances and print only the count of such tracks
zero_appearance_tracks <- track_appearances |>
  filter(num_appearances == 0)

if (nrow(zero_appearance_tracks) == 0) {
  print(0)  # Print 0 if there are no tracks with 0 appearances
} else {
  print(zero_appearance_tracks)
}
```

4. According to the song characteristics data, what is the most ‚Äúdanceable‚Äù track? How often does it appear in a playlist?

```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Most danceable track
most_danceable_track <- songs_df |>
  arrange(desc(danceability)) |>
  slice_head(n = 1) |>
  select(name, danceability)

# Count how often it appears in playlists
most_danceable_count <- songs_df |>
  filter(name == most_danceable_track$name) |>
  count()

print(most_danceable_track)
```

5. Which playlist has the longest average track length?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Find the track with the longest duration
longest_track <- songs_df |>
  arrange(desc(duration_ms)) |>
  slice_head(n = 1) |>
  select(name, duration_ms)  # Select only the name and duration columns

# Print the longest track
print(longest_track)
```

6. What is the most popular playlist on Spotify?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Find the most popular track in the dataset
most_popular_track <- songs_df |>
  arrange(desc(popularity)) |>
  slice_head(n = 1) |>
  select(name, popularity)  # Select only the name and popularity columns

# Print the most popular track
print(most_popular_track)
```

### Visually Identifying Characteristics of Popular Songs

1. Is the popularity column correlated with the number of playlist appearances?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Set CRAN mirror
options(repos = c(CRAN = "https://cran.rstudio.com"))

# Install and load necessary packages
install.packages("ggplot2")
install.packages("dplyr")
library(ggplot2)
library(dplyr)

# Summarize and calculate the number of appearances for each track
track_appearances <- songs_df |>
  group_by(name) |>
  summarise(num_appearances = n(), .groups = 'drop') |>
  arrange(desc(num_appearances))

# Limit to the top 10 tracks
top_tracks <- head(track_appearances, 10)

# Create a single bar plot of the number of appearances for the top 10 tracks
ggplot(top_tracks, aes(x = reorder(name, num_appearances), y = num_appearances)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Tracks by Number of Appearances",
       x = "Track Name",
       y = "Number of Appearances") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))
```

2. In what year were the most popular songs released?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Popularity vs. release year
most_popular_year <- songs_df |>
  group_by(year) |>
  summarise(avg_popularity = mean(popularity, na.rm = TRUE)) |>
  arrange(desc(avg_popularity)) |>
  slice_head(n = 1)

print(most_popular_year)
```

3. In what year did danceability peak?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Danceability by year
danceability_by_year <- songs_df |>
  group_by(year) |>
  summarise(avg_danceability = mean(danceability, na.rm = TRUE)) |>
  arrange(desc(avg_danceability)) |>
  slice_head(n = 1)

print(danceability_by_year)
```

4. Which decade is most represented on user playlists?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Group songs by decade
songs_df |>
  mutate(decade = (year %/% 10) * 10) |>
  group_by(decade) |>
  summarise(count = n()) |>
  arrange(desc(count)) |>
  slice_head(n = 1) |>
  print()
```

5.Create a plot of key frequency among songs.
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Plot key frequency using polar coordinates
ggplot(songs_df, aes(x = factor(key))) +
  geom_bar() +
  labs(title = "Key Distribution of Tracks",
       x = "Key",
       y = "Frequency")
```

6. What are the most popular track lengths?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Most popular track lengths with improvements for a cleaner chart
track_length_popularity <- songs_df |>
  mutate(track_length_min = duration_ms / 60000) |>
  group_by(track_length_min) |>
  summarise(popularity = mean(popularity, na.rm = TRUE)) |>
  arrange(desc(popularity))

# Create a scatter plot with a smoother to show the trend
ggplot(track_length_popularity, aes(x = track_length_min, y = popularity)) +
  geom_point(alpha = 0.5, size = 2, color = "steelblue") +  # Adjust transparency and size of points
  geom_smooth(method = "loess", color = "darkred", se = FALSE) +  # Add a smoother line
  labs(title = "Track Length vs. Popularity",
       x = "Track Length (minutes)",
       y = "Popularity") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),  # Center title and adjust font size
    axis.title = element_text(size = 12),  # Adjust axis titles
    axis.text = element_text(size = 10)  # Adjust axis labels
  )
```

7. How does the popularity of tracks vary by artist?
```{r}
#| code-fold: true
#| code-summary: "Popularity by Genre"
#| warning: false
#| message: false

# Summarize the average popularity by artist
artist_popularity <- songs_df |>
  group_by(artist) |>
  summarise(average_popularity = mean(popularity, na.rm = TRUE)) |>
  arrange(desc(average_popularity))

# Limit to top 10 artists for better readability
top_artist_popularity <- head(artist_popularity, 10)

# Plot popularity by top 10 artists
ggplot(top_artist_popularity, aes(x = reorder(artist, average_popularity), y = average_popularity)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Artists by Average Popularity",
       x = "Artist",
       y = "Average Popularity") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), 
        axis.text.y = element_text(size = 10),  
        plot.title = element_text(size = 14, face = "bold")) 
```

8. Which songs have the highest energy?
```{r}
#| code-fold: true
#| code-summary: "Popularity by Genre"
#| warning: false
#| message: false

# Find the top 10 songs with the highest energy
top_energy_songs <- songs_df |>
  arrange(desc(energy)) |>
  slice_head(n = 10)

# Plot top 10 songs with the highest energy
ggplot(top_energy_songs, aes(x = reorder(name, energy), y = energy)) +
  geom_bar(stat = "identity", fill = "darkblue") +
  coord_flip() +
  labs(title = "Top 10 Songs by Energy",
       x = "Song",
       y = "Energy Level") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Finding Related Songs
I set out to build a playlist around a couple of anchor songs that I enjoy, using data analysis to find other songs that would blend well with these anchor tracks. The goal was to apply a variety of heuristics to find at least 20 potential candidates for my playlist, ensuring that at least 8 of them were lesser-known songs, not classified as "popular."

Step 1: Selecting Anchor Songs
For this task, I selected the following anchor songs:

"Blinding Lights" by The Weeknd

"ROCKSTAR (feat. Roddy Ricch)" by DaBaby

These songs were chosen based on their high popularity and distinct characteristics, which would allow for diverse playlist candidates.

Step 2: Heuristic Methods Used
To find related songs, I applied the following heuristics:

Songs commonly appearing alongside the anchor songs in playlists: I filtered for songs that frequently appeared on playlists alongside my chosen anchor songs, providing a starting point for possible playlist candidates.

Songs with the same key and similar tempo: Music transitions more smoothly when the key and tempo are similar. For this, I filtered the dataset based on the key and tempo values of my anchor songs, ensuring that the related tracks had a similar energy and mood.

Songs by the same artist: I also explored other songs by The Weeknd and DaBaby, as they might have similar sound profiles and could fit naturally within the playlist.

Songs released in the same year with similar attributes: Since songs released in the same year often share thematic and musical similarities, I selected tracks from the same year as my anchor songs, filtering for songs that matched in characteristics such as acousticness, danceability, and loudness.

Mood-based selection: To further enhance the cohesiveness of my playlist, I chose songs with a similar "mood" to my anchor songs. For example, I looked for upbeat songs that matched the high-energy vibe of "Blinding Lights."

By using these heuristics, I identified 20 potential songs for the playlist, ensuring that at least 8 were lesser-known songs based on a popularity threshold of 50.

Step 3: Curating the Playlist
After identifying potential candidates, I narrowed the selection down to 12 songs, ensuring that:

At least 2 songs were ones I was not previously familiar with.

At least 3 of the selected tracks were not classified as ‚Äúpopular‚Äù based on their popularity scores.

I used a mix of known hits and lesser-known gems, ensuring a balance of familiarity and discovery.

Step 4: Visualizing Playlist Attributes
To ensure a cohesive flow throughout the playlist, I visualized its evolution based on attributes like energy, danceability, and tempo. The visualization allowed me to see the progression of the playlist and adjust the order of the songs to create a smooth listening experience. Here‚Äôs a brief overview of the visual analysis:

The playlist starts with high-energy songs to get the listener engaged.

As the playlist progresses, the energy levels are slightly lowered, introducing lesser-known tracks that provide depth and variety.

The tempo gradually increases toward the end, ensuring a powerful conclusion to the playlist.

Below is a sample plot showing the variation in energy across the playlist:
```{r}
#| code-fold: true
#| code-summary: "Popularity by Genre"
#| warning: false
#| message: false

# Assuming `songs_df` contains the necessary song data
playlist_songs <- c("Blinding Lights", "ROCKSTAR (feat. Roddy Ricch)", "death bed (coffee for your head)", "Funky Cold Medina")  # Add your playlist song names here

playlist_metrics <- songs_df %>%
  filter(name %in% playlist_songs) %>%
  select(name, energy, danceability, tempo, popularity)  # Select the metrics you want to analyze

# Check the data frame
print(playlist_metrics)

# Visualize energy of the playlist songs
ggplot(playlist_metrics, aes(x = reorder(name, -energy), y = energy)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Energy of Playlist Songs",
       x = "Song",
       y = "Energy Level") +
  theme_minimal()
```

## Curating and Analyzing the Ultimate Playlist
Objective: In this task, I curated my ultimate playlist, ensuring it had thematic unity and a well-considered flow. The final playlist was created not just based on data, but also by considering the emotional and musical journey that the listener would experience.

Step 1: Playlist Structure and Thematic Unity
The playlist I curated has a thematic unity centered around high-energy songs mixed with a few calmer, lesser-known tracks to give it variety and emotional depth. The overall mood is upbeat, making it ideal for a workout or a high-energy activity. The playlist starts with well-known hits to engage the listener and then transitions into deeper cuts, keeping the experience fresh.

Step 2: Playlist Name and Description
Playlist Name: "The Ultimate Workout Playlist"

Description: A playlist designed to power you through any workout, with high-energy tracks to get you moving and lesser-known gems to keep you focused and engaged. From "Blinding Lights" to underground hits, this playlist rises and falls with the energy you need to stay motivated.

Step 3: Design Principles
Flow: I ensured that the playlist flows naturally, with gradual changes in energy and tempo. The playlist starts strong, maintaining a high level of energy throughout, with some transitions into deeper cuts as the tempo slows toward the end.

Creativity: I deliberately included songs I was unfamiliar with and some lesser-known tracks, ensuring the playlist wasn‚Äôt just a collection of hits but an exploration of new sounds.

Statistical Considerations: The final playlist includes a balance of popular tracks and lesser-known songs. This ensures that the playlist isn‚Äôt too predictable, while still maintaining an engaging energy level throughout.

Step 4: Visualizing the Playlist
Below is a visualization of how the playlist's energy changes as the song order progresses, showcasing the rise and fall of the playlist‚Äôs energy:
```{r}
#| code-fold: true
#| code-summary: "Popularity by Genre"
#| warning: false
#| message: false
ggplot(playlist_metrics, aes(x = reorder(name, -energy), y = energy)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Energy Flow of The Ultimate Workout Playlist",
       x = "Song",
       y = "Energy Level") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```