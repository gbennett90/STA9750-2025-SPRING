---
title: "Spotify Songs Analysis"
author: "Gisell Bennett"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: false  # Disables numbering of sections
    embed-resources: false  # Prevent embedding resources, reduce file size
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# üìò Introduction

This mini-project explores a large Spotify playlist dataset and corresponding song characteristics. The goal is to analyze how user-created playlists reflect patterns in music preference and how these patterns align with musical attributes like energy, danceability, and valence.

## üéµ Song Characteristics Dataset

```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

load_songs <- function() {
  library(readr)
  library(dplyr)
  library(tidyr)
  library(stringr)

  # Define directory, file path, and URL
  dir_path <- "data/mp03"
  file_path <- file.path(dir_path, "songs.csv")
  url <- "https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv"

  # Create directory if it doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }

  # Download the file if it doesn't exist
  if (!file.exists(file_path)) {
    download.file(url, file_path, method = "libcurl")
  }

  # Read the CSV
  SONGS <- read_csv(file_path, show_col_types = FALSE)

  # Clean and split artist list
  SONGS_clean <- SONGS |>
    mutate(
      artists = str_remove_all(artists, "\\[|\\]|'") 
    ) |>
    separate_rows(artists, sep = ",\\s*") |>           
    rename(artist = artists)                           

  return(SONGS_clean)
}

songs_df <- load_songs()
head(songs_df)
```

## üìù Spotify Million Playlist Dataset

In Task 2, I encountered an issue where the Spotify Million Playlist Dataset was no longer available for download from the original GitHub URL, as pointed out in the Piazza review and feedback from both the professor and students. Many of the files returned 404 errors, so I focused on downloading the first chunk (mpd.slice.0-999.json) to determine if any data was still accessible. Using the httr package, I checked the file's availability and downloaded it if found. If there were errors or missing files, the script would notify me. This approach enabled me to proceed with the analysis despite the missing data.

```{r}
#| message: false
#| warning: false
#| code-fold: true
#| code-summary: Show Code
#| include: false

# Load necessary libraries
library(httr)
library(jsonlite)  # Needed for fromJSON()

# Define the base URL for the dataset on GitHub
base_url <- "https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/refs/heads/main/data1/"

# Choose a smaller file (e.g., a smaller chunk or slice file)
file_name <- "mpd.slice.0-999.json"  # Example file, could be smaller than other files

# Construct the full URL for the file
file_url <- paste0(base_url, file_name)

# Check if the file exists by trying to fetch it
response <- httr::GET(file_url)

# If the status is OK (HTTP 200), save the file locally
if (httr::status_code(response) == 200) {
  
  local_file_path <- paste0("spotify_data/", file_name)
  
  if (!dir.exists("spotify_data")) {
    dir.create("spotify_data")
  }
  
  writeBin(httr::content(response, "raw"), local_file_path)
  print(paste("Downloaded:", file_name))
} else {
  print(paste("Error downloading:", file_name, "- Received status code", httr::status_code(response)))
}

# Load and process the downloaded JSON file (if it exists)
if (file.exists(local_file_path)) {
  
  json_data <- fromJSON(local_file_path)
  
  # Convert json_data to a data frame (if it's a list or nested structure)
  # You might need to navigate through the nested structure depending on the data
  json_data_df <- as.data.frame(json_data)

  # Limit to first 10 rows
  small_json_data <- head(json_data_df, 10)
  
  print("Inspecting the first few records from the dataset (limited to 10 records):")
  print(small_json_data)
} else {
  print("No data found to load.")
}
```

## Questions
### Identifying Characteristics of Popular Songs

1. How many distinct tracks and artists are represented in the playlist data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Number of distinct tracks
distinct_tracks <- songs_df |>
  distinct(name) |>
  count()

# Number of distinct artists
distinct_artists <- songs_df |>
  distinct(artist) |>
  count()

print(paste("Distinct tracks:", distinct_tracks$n))
print(paste("Distinct artists:", distinct_artists$n))
```
2. What are the 5 most popular tracks in the playlist data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Top 5 most popular tracks
top_5_popular_tracks <- songs_df |>
  arrange(desc(popularity)) |>
  slice_head(n = 5) |>
  select(name, popularity)

print(top_5_popular_tracks)
```

3. What is the most popular track in the playlist data that does not have a corresponding entry in the song characteristics data?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Summarize and calculate the number of appearances for each track
track_appearances <- songs_df |>
  group_by(name) |>
  summarise(num_appearances = n(), .groups = 'drop') |>
  arrange(desc(num_appearances))

# Check if there are any tracks with 0 appearances and print only the count of such tracks
zero_appearance_tracks <- track_appearances |>
  filter(num_appearances == 0)

if (nrow(zero_appearance_tracks) == 0) {
  print(0)  # Print 0 if there are no tracks with 0 appearances
} else {
  print(zero_appearance_tracks)
}
```

4. According to the song characteristics data, what is the most ‚Äúdanceable‚Äù track? How often does it appear in a playlist?

```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Most danceable track
most_danceable_track <- songs_df |>
  arrange(desc(danceability)) |>
  slice_head(n = 1) |>
  select(name, danceability)

# Count how often it appears in playlists
most_danceable_count <- songs_df |>
  filter(name == most_danceable_track$name) |>
  count()

print(most_danceable_track)
```

5. Which playlist has the longest average track length?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Find the track with the longest duration
longest_track <- songs_df |>
  arrange(desc(duration_ms)) |>
  slice_head(n = 1) |>
  select(name, duration_ms)  # Select only the name and duration columns

# Print the longest track
print(longest_track)
```

6. What is the most popular playlist on Spotify?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Find the most popular track in the dataset
most_popular_track <- songs_df |>
  arrange(desc(popularity)) |>
  slice_head(n = 1) |>
  select(name, popularity)  # Select only the name and popularity columns

# Print the most popular track
print(most_popular_track)
```

### Visually Identifying Characteristics of Popular Songs

1. Is the popularity column correlated with the number of playlist appearances?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Set CRAN mirror
options(repos = c(CRAN = "https://cran.rstudio.com"))

# Install and load necessary packages
install.packages("ggplot2")
install.packages("dplyr")
library(ggplot2)
library(dplyr)

# Summarize and calculate the number of appearances for each track
track_appearances <- songs_df |>
  group_by(name) |>
  summarise(num_appearances = n(), .groups = 'drop') |>
  arrange(desc(num_appearances))

# Limit to the top 10 tracks
top_tracks <- head(track_appearances, 10)

# Create a single bar plot of the number of appearances for the top 10 tracks
ggplot(top_tracks, aes(x = reorder(name, num_appearances), y = num_appearances)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Tracks by Number of Appearances",
       x = "Track Name",
       y = "Number of Appearances") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 10),
        axis.text.y = element_text(size = 10))
```

2. In what year were the most popular songs released?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Popularity vs. release year
most_popular_year <- songs_df |>
  group_by(year) |>
  summarise(avg_popularity = mean(popularity, na.rm = TRUE)) |>
  arrange(desc(avg_popularity)) |>
  slice_head(n = 1)

print(most_popular_year)
```

3. In what year did danceability peak?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Danceability by year
danceability_by_year <- songs_df |>
  group_by(year) |>
  summarise(avg_danceability = mean(danceability, na.rm = TRUE)) |>
  arrange(desc(avg_danceability)) |>
  slice_head(n = 1)

print(danceability_by_year)
```

4. Which decade is most represented on user playlists?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Group songs by decade
songs_df |>
  mutate(decade = (year %/% 10) * 10) |>
  group_by(decade) |>
  summarise(count = n()) |>
  arrange(desc(count)) |>
  slice_head(n = 1) |>
  print()
```

5.Create a plot of key frequency among songs.
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Plot key frequency using polar coordinates
ggplot(songs_df, aes(x = factor(key))) +
  geom_bar() +
  labs(title = "Key Distribution of Tracks",
       x = "Key",
       y = "Frequency")
```

6. What are the most popular track lengths?
```{r}
#| code-fold: true
#| code-summary: "Show Code"
#| warning: false
#| message: false

# Most popular track lengths with improvements for a cleaner chart
track_length_popularity <- songs_df |>
  mutate(track_length_min = duration_ms / 60000) |>
  group_by(track_length_min) |>
  summarise(popularity = mean(popularity, na.rm = TRUE)) |>
  arrange(desc(popularity))

# Create a scatter plot with a smoother to show the trend
ggplot(track_length_popularity, aes(x = track_length_min, y = popularity)) +
  geom_point(alpha = 0.5, size = 2, color = "steelblue") +  # Adjust transparency and size of points
  geom_smooth(method = "loess", color = "darkred", se = FALSE) +  # Add a smoother line
  labs(title = "Track Length vs. Popularity",
       x = "Track Length (minutes)",
       y = "Popularity") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16),  # Center title and adjust font size
    axis.title = element_text(size = 12),  # Adjust axis titles
    axis.text = element_text(size = 10)  # Adjust axis labels
  )
```